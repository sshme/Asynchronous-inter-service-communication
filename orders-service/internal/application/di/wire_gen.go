// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package di

import (
	"context"
	"fmt"
	redis2 "github.com/redis/go-redis/v9"
	"orders-service/internal/application/service"
	"orders-service/internal/infrastructure/brokers/kafka"
	"orders-service/internal/infrastructure/config"
	"orders-service/internal/infrastructure/persistence/postgres"
	"orders-service/internal/infrastructure/pubsub/redis"
	"orders-service/internal/infrastructure/sse"
	"orders-service/internal/interfaces/api/router"
	"orders-service/internal/interfaces/repository"
	"orders-service/pkg/random"
)

// Injectors from wire.go:

func InitializeApplication() (*Application, func(), error) {
	app := NewConfigApp()
	configConfig := config.MustLoad(app)
	postgresConfig := NewPostgresConfig(configConfig)
	db, err := postgres.NewDb(postgresConfig)
	if err != nil {
		return nil, nil, err
	}
	ordersRepository := postgres.NewOrdersRepository(db)
	outboxRepository := postgres.NewOutboxRepository(db)
	cryptoGenerator := random.NewCryptoGenerator()
	redisConfig := NewRedisConfig(configConfig)
	client, cleanup, err := NewRedisClient(redisConfig)
	if err != nil {
		return nil, nil, err
	}
	publisher := redis.NewPublisher(client, redisConfig)
	ordersService := service.NewOrdersService(ordersRepository, outboxRepository, cryptoGenerator, publisher, db)
	subscriber := redis.NewSubscriber(client, redisConfig)
	manager := sse.NewManager(subscriber)
	routerRouter := router.NewRouter(ordersService, manager)
	kafkaConfig := kafka.NewConfig(configConfig)
	outboxPublisher := NewOutboxPublisher(outboxRepository, kafkaConfig)
	inboxRepository := postgres.NewInboxRepository(db)
	inboxProcessor := NewInboxProcessor(inboxRepository, kafkaConfig)
	application := NewApplication(routerRouter, configConfig, outboxPublisher, inboxProcessor, ordersService, manager)
	return application, func() {
		cleanup()
	}, nil
}

// wire.go:

func NewConfigApp() *config.App {
	return config.NewApp("config/config.yaml")
}

func NewPostgresConfig(appConfig *config.Config) *postgres.Config {
	return &postgres.Config{
		Host: appConfig.Db.Host,
		Port: appConfig.Db.Port,
		User: appConfig.Db.User,
		Pass: appConfig.Db.Pass,
		Name: appConfig.Db.Name,
	}
}

func NewRedisConfig(appConfig *config.Config) *redis.Config {
	return &redis.Config{
		Host:    appConfig.Redis.Host,
		Port:    appConfig.Redis.Port,
		Channel: appConfig.Redis.Channel,
	}
}

func NewRedisClient(redisConfig *redis.Config) (*redis2.Client, func(), error) {
	client := redis2.NewClient(&redis2.Options{
		Addr: fmt.Sprintf("%s:%d", redisConfig.Host, redisConfig.Port),
	})

	if err := client.Ping(context.Background()).Err(); err != nil {
		return nil, nil, err
	}

	cleanup := func() {
		client.Close()
	}

	return client, cleanup, nil
}

func NewOutboxPublisher(
	outboxRepo repository.OutboxRepository,
	kafkaConfig *kafka.Config,
) *kafka.OutboxPublisher {
	publisher, err := kafka.NewOutboxPublisher(outboxRepo, kafkaConfig)
	if err != nil {
		panic(err)
	}
	return publisher
}

func NewInboxProcessor(
	inboxRepo repository.InboxRepository,
	kafkaConfig *kafka.Config,
) *kafka.InboxProcessor {
	processor, err := kafka.NewInboxProcessor(inboxRepo, kafkaConfig)
	if err != nil {
		panic(err)
	}
	return processor
}

type Application struct {
	Router          *router.Router
	Config          *config.Config
	OutboxPublisher *kafka.OutboxPublisher
	InboxProcessor  *kafka.InboxProcessor
	OrdersService   *service.OrdersService
	SSEManager      *sse.Manager
}

func NewApplication(
	rtr *router.Router,
	cfg *config.Config,
	outboxPub *kafka.OutboxPublisher,
	inboxProc *kafka.InboxProcessor,
	ordSvc *service.OrdersService,
	sseMgr *sse.Manager,
) *Application {
	return &Application{
		Router:          rtr,
		Config:          cfg,
		OutboxPublisher: outboxPub,
		InboxProcessor:  inboxProc,
		OrdersService:   ordSvc,
		SSEManager:      sseMgr,
	}
}
